package main

import (
	"flag"
	"fmt"
	"os"
	"text/template"

	"github.com/goccy/go-yaml"
)

// RegionConfig represents a single region configuration from regions.yaml.
type RegionConfig struct {
	ID   string `yaml:"id"`
	Name string `yaml:"name"`
	Tag  string `yaml:"tag"`
}

// RegionsConfig represents the full regions.yaml structure.
type RegionsConfig struct {
	Regions []RegionConfig `yaml:"regions"`
}

// TemplateData holds the data passed to the GoReleaser template.
type TemplateData struct {
	Regions []RegionConfig
}

const goreleaserTemplate = `# Generated by tools/generate-goreleaser - DO NOT EDIT MANUALLY
# Regenerate with: make generate-goreleaser

version: 2

builds:
{{- range .Regions}}
  - id: {{.Name}}
    main: ./cmd/pulumicost-plugin-aws-public
    binary: pulumicost-plugin-aws-public-{{.Name}}
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    tags:
      - {{.Tag}}
    ldflags:
      - -s -w -X main.version={{"{{"}} .Version {{"}}"}}
{{end}}
archives:
  - formats:
      - tar.gz
    name_template: >-
      {{"{{"}} .ProjectName {{"}}"}}_
      {{"{{"}} .Version {{"}}"}}_
      {{"{{"}} title .Os {{"}}"}}_
      {{"{{"}} if eq .Arch "amd64" {{"}}"}}x86_64
      {{"{{"}} else if eq .Arch "386" {{"}}"}}i386
      {{"{{"}} else {{"}}"}}{{"{{"}} .Arch {{"}}"}}{{"{{"}} end {{"}}"}}
      {{"{{"}} if .Arm {{"}}"}}v{{"{{"}} .Arm {{"}}"}}{{"{{"}} end {{"}}"}}
    format_overrides:
      - goos: windows
        formats:
          - zip

checksum:
  name_template: checksums.txt

snapshot:
  name_template: "{{"{{"}} incpatch .Version {{"}}"}}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"
      - "chore:"
      - "Merge pull request"
      - "Merge branch"

source:
  enabled: false
`

func main() {
	configPath := flag.String("config", "regions.yaml", "Path to regions config")
	outputPath := flag.String("output", ".goreleaser.yaml", "Output file path")
	flag.Parse()

	// Load regions config
	regions, err := loadRegionsConfig(*configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading regions config: %v\n", err)
		os.Exit(1)
	}

	// Validate regions
	if err := validateRegions(regions); err != nil {
		fmt.Fprintf(os.Stderr, "Validation error: %v\n", err)
		os.Exit(1)
	}

	// Generate GoReleaser config
	if err := generateGoReleaserConfig(regions, *outputPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating GoReleaser config: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated GoReleaser config at %s with %d regions\n", *outputPath, len(regions))
}

func loadRegionsConfig(filename string) ([]RegionConfig, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var config RegionsConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return config.Regions, nil
}

func validateRegions(regions []RegionConfig) error {
	seen := make(map[string]bool)
	for _, r := range regions {
		if r.ID == "" {
			return fmt.Errorf("region missing id")
		}
		if r.Name == "" {
			return fmt.Errorf("region %s missing name", r.ID)
		}
		if r.Tag == "" {
			return fmt.Errorf("region %s missing tag", r.ID)
		}
		expectedTag := "region_" + r.ID
		if r.Tag != expectedTag {
			return fmt.Errorf("region %s tag mismatch: expected %s, got %s", r.ID, expectedTag, r.Tag)
		}
		if seen[r.ID] {
			return fmt.Errorf("duplicate region id: %s", r.ID)
		}
		seen[r.ID] = true
	}
	return nil
}

func generateGoReleaserConfig(regions []RegionConfig, outputPath string) error {
	data := TemplateData{
		Regions: regions,
	}

	tmpl, err := template.New("goreleaser").Parse(goreleaserTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	if err = tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	return nil
}
